Q1.What are the important methods that are declared in the collection interface?
Ans.Most important methods declared in the collection interface are the methods to add and remove an element.
size() methods returns number of elements in the collection
interface Collection<E> extends Iterable<E>
{
  boolean add(E paramE);
  boolean remove(Object paramObject);

  int size();
  boolean isEmpty();
  void clear();

  boolean contains(Object paramObject);
  boolean containsAll(Collection<?> paramCollection);
  
  boolean addAll(Collection<? extends E> paramCollection);
  boolean removeAll(Collection<?> paramCollection);
  boolean retainAll(Collection<?> paramCollection);
  

  Iterator<E> iterator();

  //A NUMBER OF OTHER METHODS AS WELL..
}

Q2.Why do we need Collections in Java?
Ans.Arrays are not dynamic. Once an array of a particular size is declared, the size cannot be modified. To add a new element to the array, a new array has to be created with bigger size and all the elements from the old array copied to new array.

Collections are used in situations where data is dynamic. Collections allow adding an element, deleting an element and host of other operations. There are a number of Collections in Java allowing to choose the right Collection for the right context.


Q3.Can you explain briefly about the List Interface?
Ans.List interface extends Collection interface. So, it contains all methods defined in the Collection interface. In addition, List interface allows operation specifying the position of the element in the Collection
2.any implementation of the List interface would maintain the insertion order.
3.When a new element is inserted without specifying a position, it is inserted at the end of the list of elements.
4.However, We can also use the void add(int position, E paramE); method to insert an element at a specific position

interface List<E> extends Collection<E>
{
  boolean addAll(int paramInt, Collection<? extends E> paramCollection);

  E get(int paramInt);
  E set(int paramInt, E paramE);

  void add(int paramInt, E paramE);
  E remove(int paramInt);

  int indexOf(Object paramObject);
  int lastIndexOf(Object paramObject);

  ListIterator<E> listIterator();
  ListIterator<E> listIterator(int paramInt);
  List<E> subList(int paramInt1, int paramInt2);
}


Q5.Can you briefly explain about the Map Interface?
Ans.
1.First and foremost, Map interface does not extend Collection interface. So, it does not inherit any of the methods from the Collection interface
2.A Map interface supports Collections that use a key value pair. A key-value pair is a set of linked data items: a key, which is a unique identifier for some item of data, and the value, which is either the data or a pointer to the data. Key-value pairs are used in lookup tables, hash tables and configuration files. A key value pair in a Map interface is called an Entry.

interface Map<K, V>
{
  int size();
  boolean isEmpty();

  boolean containsKey(Object paramObject);
  boolean containsValue(Object paramObject);

  V get(Object paramObject);
  V put(K paramK, V paramV);
  V remove(Object paramObject);

  void putAll(Map<? extends K, ? extends V> paramMap);
  void clear();

  Set<K> keySet();
  Collection<V> values();
  Set<Entry<K, V>> entrySet();

  boolean equals(Object paramObject);
  int hashCode();

  public static abstract interface Entry<K, V>
  {
    K getKey();
    V getValue();
    V setValue(V paramV);
    boolean equals(Object paramObject);
    int hashCode();
  }
}
Q6.What is the difference between Set and SortedSet?
Ans.SortedSet Interface extends the Set Interface. Both Set and SortedSet do not allow duplicate elements.
2.Main difference between Set and SortedSet is - an implementation of SortedSet interface maintains its elements in a sorted order. Set interface does not guarantee any Order.

public interface SortedSet<E> extends Set<E> {
    
    SortedSet<E> subSet(E fromElement, E toElement);
    SortedSet<E> headSet(E toElement);
    SortedSet<E> tailSet(E fromElement);
    
    E first();
    E last();

    Comparator<? super E> comparator();
}

Q7.What is difference between Map and SortedMap?
Ans.SortedMap interface extends the Map interface. In addition, an implementation of SortedMap interface maintains keys in a sorted order.

public interface SortedMap<K, V> extends Map<K, V> {
    Comparator<? super K> comparator();

    SortedMap<K, V> subMap(K fromKey, K toKey);

    SortedMap<K, V> headMap(K toKey);

    SortedMap<K, V> tailMap(K fromKey);

    K firstKey();

    K lastKey();
}

Q8.Explain briefly about Queue Interface?
Ans.Queue Interface extends Collection interface. Queue Interface is typically used for implementation holding elements in order for some processing.
2.Queue interface offers methods peek() and poll() which get the element at head of the queue. The difference is that poll() method removes the head from queue also. peek() would keep head of the queue unchanged.
interface Queue<E> extends Collection<E>
{
  boolean offer(E paramE);
  E remove();
  E poll();
  E element();
  E peek();
}

Q9.Explain briefly about Iterator?
Ans.
1.Iterator interface enables us to iterate (loop around) a collection. All collections define a method iterator() that gets an iterator of the collection.
2.hasNext() checks if there is another element in the collection being iterated. next() gets the next element.

public interface Iterator<E> {
    boolean hasNext();

    E next();
}
Q10.What is LinkedList? What interfaces does it implement? How is it different from an ArrayList?
Ans.Linked List extends List and Queue.Other than operations exposed by the Queue interface, LinkedList has the same operations as an ArrayList. However, the underlying implementation of Linked List is different from that of an ArrayList.
2.ArrayList uses an Array kind of structure to store elements. So, inserting and deleting from an ArrayList are expensive operations. However, search of an ArrayList is faster than LinkedList.
3.LinkedList uses a linked representation. Each object holds a link to the next element. Hence, insertion and deletion are faster than ArrayList. But searching is slower.

Q11.What is a TreeSet? How is different from a HashSet?
Ans.TreeSet implements Set, SortedSet and NavigableSet interfaces.TreeSet is similar to HashSet except that it stores element’s in Sorted Order.
Q12.What are the important methods in the NavigableSet interface?
Ans.Lower method finds the highest element lower than specified element. Floor method finds the highest element lower than or equal to specified element. Corresponding methods for finding lowest number higher than specified element are higher and ceiling.

Q12.What is a PriorityQueue?
Ans.PriorityQueue implements the Queue interface.
//Using default constructor - uses natural ordering of numbers
//Smaller numbers have higher priority
PriorityQueue<Integer> priorityQueue = new PriorityQueue<Integer>();
//This comparator gives high priority to the biggest number.
Comparator reverseComparator = new Comparator<Integer>() {
    public int compare(Integer paramT1,
            Integer paramT2) {
        return paramT2 - paramT1;
    }

};


Q13.What is the difference between synchronized and concurrent collections in Java?
Ans.Synchronized collections are implemented using synchronized methods and synchronized blocks. Only one thread can executing any of the synchronized code at a given point in time. This places severe restrictions on the concurrency of threads – thereby affecting performance of the application. All the pre Java 5 synchronized collections (HashTable & Vector, for example) use this approach.

Q14.Explain about the new concurrent collections in Java?
Ans.Post Java 5, collections using new approaches to synchronization are available in Java. These are called concurrent collections.

Copy on Write
Compare and Swap
Locks

Q14.Explain about CopyOnWrite concurrent collections approach?
Ans.Important points about Copy on Write approach

All values in collection are stored in an internal immutable (not-changeable) array. A new array is created if there is any modification to the collection.
Read operations are not synchronized. Only write operations are synchronized.
Ex. CopyOnWriteArrayList & CopyOnWriteArraySet are implementations of this approach.

Q15.What is CompareAndSwap approach?
Compare and Swap is one of the new approaches (Java 5) introduced in java to handle synchronization. In traditional approach, a method which modifies a member variable used by multiple threads is completely synchronized – to prevent other threads accessing stale value.

In compare and swap approach, instead of synchronizing entire method, the value of the member variable before calculation is cached. After the calculation, the cached value is compared with the current value of member variable. If the value is not modified, the calculated result is stored into the member variable. If another thread has modified the value, then the calculation can be performed again.

Ex.ConcurrentLinkedQueue uses this approach.

Q16.What is a Lock? How is it different from using synchronized approach?
When 10 methods are declared as synchronized, only one of them is executed by any of the threads at any point in time. This has severe performance impact.

Another new approach introduced in Java 5 is to use lock and unlock methods. Lock and unlock methods are used to divide methods into different blocks and help enhance concurrency. The 10 methods can be divided into different blocks, which can be synchronized based on different variables.

Q17.When does a Java collection throw UnsupportedOperationException?
Ans.All Java Collections extend Collection interface. So, they have to implement all the methods in the Collection interface. However, certain Java collections are optimized to be used in specific conditions and do not support all the Collection operations (methods). When an unsupported operation is called on a Collection, the Collection Implementation would throw an UnsupportedOperationException.
2.Arrays.asList returns a fixed-size list backed by the specified array. When an attempt is made to add or remove from this collection an UnsupportedOperationException is thrown.
3.List<String> list=Arrays.asList(new String[]{"ac","bddefe"});
list.remove();//throws UnsupportedOperationException

Q18.Intermediate Operations are of two kinds
Ans.Stateful : Elements need to be compared against one another (sort, distinct etc)
Stateless : No need for comparing with other elements (map, filter etc).

Q19.What is BlockedQueue in Java?
BlockedQueue interface is introduced in Java specifically to address specific needs of some Producer Consumer scenarios. BlockedQueue allows the consumer to wait (for a specified time or infinitely) for an element to become availabl.

Q42.What is serialization?
Ans.
1.Serialization is a mechanism by which we convert object state into byte stream so it can easily tranmitted over network.
Deserialization is reverse process of serialization convert byte stream object into  java actual object in memory.
Case 1: If superclass is serializable then subclass is automatically serializable : If superclass is Serializable, then by default every subclass is serializable. Hence, even though subclass doesn’t implement Serializable interface( and if it’s superclass implements Serializable), then we can serialize subclass object.
2.If a superclass is not serializable then subclass can still be serialized : Even though superclass doesn’t implements Serializable interface, we can serialize subclass object if subclass itself implements Serializable interface. So we can say that to serialize subclass object, superclass need not to be serializable. But what happens with the instances of superclass during serialization in this case.
Q43.What happens when a class is serializable but its superclass is not ?
Ans.Serialization: At the time of serialization, if any instance variable is inheriting from non-serializable superclass, then JVM ignores original value of that instance variable and save default value to the file.
De- Serialization: At the time of de-serialization, if any non-serializable superclass is present, then JVM will execute instance control flow in the superclass. To execute instance control flow in a class, JVM will always invoke default(no-arg) constructor of that class. So every non-serializable superclass must necessarily contain default constructor, otherwise we will get runtime-exception.

Q44.If the superclass is serializable but we don’t want the subclass to be serialized 
here is no direct way to prevent subclass from serialization in java. One possible way by which a programmer can achieve this is by implementing the writeObject() and readObject() methods in the subclass and needs to throw NotSerializableException from these methods. These methods are executed during serialization and de-serialization respectively. By overriding these methods, we are just implementing our own custom serialization.
Q46.Are the values of static variables stored when an object is serialized?
Ans.Instance Variables: These variables are serialized, so during deserialization we will get back the serialized state.

Static Variables: These variables are not serialized, So during deserialization static variable value will loaded from the class.(Current value will be loaded.)

transient Variables: transient variables are not serialized, so during deserialization those variables will be initialized with corresponding default values (ex: for objects null, int 0).

Super class variables: If super class also implemented Serializable interface then those variables will be serialized, otherwise it won't serialize the super class variables. and while deserializing, JVM will run default constructor in super class and populates the default values. Same thing will happen for all superclasses.

serialVersionUID is a special static variable used by the serialization and deserialization process, to verify that a local class is compatible with the class used to serialize an object. It's not just a static variable as others, which are definitely not serialized.

When an object of a class is first serialized, a class descriptor containing among other things the class name and serial version UID is written to the stream. When this is deserialized, the JVM checks if the serial version UID read from the stream is the same as the one of the local class. If they're not, it doesn't even try to deserialize the object, because it knows the classes are incompatible.

serialVersionUID is special and is not subject to these rules. There is code within the serialization machinery that specifically handles this field to perform the automatic version checks


Q40.What are asserts used for?
Ans.An assertion allows testing the correctness of any assumptions that have been made in the program.
assert age >= 20 : " under age";
Q41.What is tokenizing?
Ans.StringTokenizer class in Java is used to break a string into tokens.
A StringTokenizer object internally maintains a current position within the string to be tokenized.

StringTokenizer(String str) :
str is string to be tokenized.
Considers default delimiters like new line, space, tab, 
carriage return and form feed.

StringTokenizer(String str, String delim) :
delim is set of delimiters that are used to tokenize
the given string.

StringTokenizer(String str, String delim, boolean flag):
The first two parameters have same meaning.  The flag 
serves following purpose.

If the flag is false, delimiter characters serve to 
separate tokens. For example, if string is "hello geeks"
and delimiter is " ", then tokens are "hello" and "geeks".

If the flag is true, delimiter characters are 
considered to be tokens. For example, if string is "hello
 geeks" and delimiter is " ", then tokens are "hello", " " 
and "geeks".

Q39.Can you explain a few exception handling best practices?
Ans.1. Prefer Specific Exceptions
2. Document the Exceptions You Specify
3. Throw Exceptions With Descriptive Messages
4. Catch the Most Specific Exception First
5. Don’t Catch Throwable
6. Don’t Ignore Exceptions
7.Wrap the Exception Without Consuming It

Q38.How does try with resources work?
Ans.1. Automatic Resource Management(ARM) using try-with-resources from Java 7 onwards. The try-with-resources statement is a try statement that declares one or more resources.
2.This statement ensures that each resource is closed at the end of the statement which eases working with external resources that need to be disposed or closed in case of errors or successful completion of a code block.
3. What is a resource?
A resource is an object that must be closed after the program is finished using it. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource.

In try-with-resources method there is no use of finally block. the file resource is opened in try block inside small brackets. Only the objects of those classes can be opened within the block which implements AutoCloseable interface and those object should also be local. The resource will be closed automatically regardless of whether try statement completes normally or abruptly.

static String readFirstLineFromFile(String path) throws IOException
{
    try (BufferedReader br = new BufferedReader(new FileReader(path)))
    {
        return br.readLine();
    }
}

Multiple resources can be used inside a try-with-resources block and have them all automatically closed. In this case, the resources will be closed in the reverse order in which they were created inside the brackets.


Q37.What happens when a variable is marked as volatile?
Ans. Basically, the value of a volatile field becomes visible to all readers (other threads in particular) after a write operation completes on it. Without volatile, readers could see some non-updated value.
2.the volatile modifier guarantees that any thread that reads a field will see the most recently written value
public class Singleton {
    private static volatile Singleton _instance; // volatile variable
    public static Singleton getInstance() {
        if (_instance == null) {
            synchronized (Singleton.class) {
                if (_instance == null)
                    _instance = new Singleton();
            }
        }
        return _instance;
    }
}
We are creating instance lazily at the time the first request comes.

If we do not make the _instance variable volatile then the Thread which is creating the instance of Singleton is not able to communicate to the other thread. So if Thread A is creating Singleton instance and just after creation, the CPU corrupts etc, all other threads will not be able to see the value of _instance as not null and they will believe it is still assigned null.

Why does this happen? Because reader threads are not doing any locking and until the writer thread comes out of a synchronized block, the memory will not be synchronized and value of _instance will not be updated in main memory. With the Volatile keyword in Java, this is handled by Java itself and such updates will be visible by all reader threads.

Conclusion: volatile keyword is also used to communicate the content of memory between threads.


Important point about volatile:

Synchronization in Java is possible by using Java keywords synchronized and volatile and locks.
In Java, we can not have synchronized variable. Using synchronized keyword with a variable is illegal and will result in compilation error. Instead of using the synchronized variable in Java, you can use the java volatile variable, which will instruct JVM threads to read the value of volatile variable from main memory and don’t cache it locally.
If a variable is not shared between multiple threads then there is no need to use the volatile keyword.
source

Example usage of volatile:

public class Singleton {
    private static volatile Singleton _instance; // volatile variable
    public static Singleton getInstance() {
        if (_instance == null) {
            synchronized (Singleton.class) {
                if (_instance == null)
                    _instance = new Singleton();
            }
        }
        return _instance;
    }
}
We are creating instance lazily at the time the first request comes.

If we do not make the _instance variable volatile then the Thread which is creating the instance of Singleton is not able to communicate to the other thread. So if Thread A is creating Singleton instance and just after creation, the CPU corrupts etc, all other threads will not be able to see the value of _instance as not null and they will believe it is still assigned null.

Why does this happen? Because reader threads are not doing any locking and until the writer thread comes out of a synchronized block, the memory will not be synchronized and value of _instance will not be updated in main memory. With the Volatile keyword in Java, this is handled by Java itself and such updates will be visible by all reader threads.

Conclusion: volatile keyword is also used to communicate the content of memory between threads.

Example usage of without volatile:

public class Singleton{    
    private static Singleton _instance;   //without volatile variable
    public static Singleton getInstance(){   
          if(_instance == null){  
              synchronized(Singleton.class){  
               if(_instance == null) _instance = new Singleton(); 
      } 
     }   
    return _instance;  
    }
The code above is not thread-safe. Although it checks the value of instance once again within the synchronized block (for performance reasons), the JIT compiler can rearrange the bytecode in a way that the reference to the instance is set before the constructor has finished its execution. This means the method getInstance() returns an object that may not have been initialized completely. To make the code thread-safe, the keyword volatile can be used since Java 5 for the instance variable. Variables that are marked as volatile get only visible to other threads once the constructor of the object has finished its execution completely



Q36.What is a final argument?
Ans.public void doSomething(final int i, final int j)
{
  // cannot change the value of i or j here...
  // any change would be visible only inside the method...
}

The final keyword when used for parameters/variables in Java marks the reference as final. In case of passing an object to another method, the system creates a copy of the reference variable and passes it to the method. By marking the new references final, you protect them from reassignment. It's considered sometimes a good coding practice.


Q35.When do you use an abstract class?
Ans. 1. I know basic use of abstract classes is to create templates for future classes
2.Abstract Classes are a good fit if you want to provide implementation details to your children but don't want to allow an instance of your class to be directly instantiated.
–> The purpose of an abstract class is to provide a common definition of a base class that multiple derived classes can share.
3.Abstract classes/methods are generally used when a class provides some high level functionality but leaves out certain details to be implemented by derived classes. Making the class/method abstract ensures that it cannot be used on its own, but must be specialized to define the details that have been left out of the high level implementation
Q34.Can super class reference variable can hold an object of sub class?
Ans.
1.First approach (Referencing using Superclass reference): A reference variable of a superclass can be used to a refer any subclass object derived from that superclass. If the methods are present in SuperClass, but overridden by SubClass, it will be the overridden method that will be executed.
2.Second approach (Referencing using subclass reference) : A subclass reference can be used to refer its object.
Disadvantage : By using superclass reference, we will have access only to those parts(methods and variables) of the object defined by the superclass. For example, we can not access seatHeight variable or call setHeight(int newValue) method using Bicycle reference in above first example. This is because they are defined in subclass not in the superclass.

Advantage : By using subclass reference, we will have access to both parts(methods and variables) of the object defined by the superclass or subclass. For example, we can call setHeight(int newValue) method or speedUp(int increment) method using MountainBike reference in above first example


Q33.What is the Hashcode method used for in Java?
Ans.hashing algorithms stand behind some of the most popular collections we have available – such as the HashMap.When using a hash table, these collections calculate the hash value for a given key using the hashCode() method and use this value internally to store the data – so that access operations are much more efficient.Simply put, hashCode() returns an integer value, generated by a hashing algorithm.Objects that are equal (according to their equals()) must return the same hash code.

@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    System.out.println("Object hashCOde :" + this.name + hash);
    return hash;
}

each time an object is stored in the hash map and checked with the containsKey() method, hashCode() is invoked and the computed hash code.

	Employee emp1 = new Employee("anuj", 12, "Male");
		Employee emp2 = new Employee("amit", 12, "Male");
		Employee emp3 = new Employee("anuj", 12, "male");
		Map<Employee, Employee> map = new HashMap<>();
		map.put(emp1, emp2);
		map.put(emp2, emp3);

		if (map.containsKey(emp3)) {
			System.out.println("Employee found in Collections");
		}
Output:
Object hashCOde :anuj77327002
Object hashCOde :amit77325679
Object hashCOde :anuj106879674

Q32.What is the use of equals method in Java?
Ans.
1.This method’s functionality is to check if the object invoking this method is equal to another object passed as an argument. It should return true if the objects are equal, otherwise it should return false.
2.It is generally necessary to override the hashCode() method whenever the equals() method is overridden, so as to maintain the general contract for the hashCode() method, which states that equal objects must have equal hash codes.

@Override
	public boolean equals(Object obj) {

		if (obj == null) {
			return false;
		}
      if (this == obj)
			return true;
		if (!(obj instanceof Employee)) {
			return false;
		}
		Employee emp = (Employee) obj;

		return (this.name.equals(emp.name)) && (this.age == emp.age) && (this.gender.equals(emp.gender));

	}
   
  1.Whenever a.equals(b), then a.hashCode() must be same as b.hashCode().

Q31.Explain about toString method ?
Ans.
1.It returns a string representation of the object The result should be a concise but informative representation that is easy for a person to read. It's also widely used for logging, and for passing informative error messages to Exception constructors and assertions.
2.The toString() is a method that is defined in the java.lang.Object class and thus, every object has one, however, it prints out, for the most part, meaningless information. Since its default implementation doesn't provide much information.
3.By default the toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object.
4.getClass().getName() + '@' + Integer.toHexString(hashCode()).
5. We can override toString method in our Class like 

@Override
	public String toString() {
		return "Manufacturer: " + name + " \nGear: " + gear;
	}
   
   
6.How to toString() works?
Ans.toString() with Concatenation 
Whenever we concatenate any other primitive data type, or object of other classes with a String object, toString() function or valueOf() function is called automatically to change the other object or primitive type into string, for successful concatenation.

int gear = 6;
String str = "Car has " + gear + " gears.";

Q32.When to use toString() method?
Ans.In Java, toString method guarantees that an object can be represented textually.This is especially useful for logging, debugging, or any other circumstance where you need to be able to render any and every object you encounter as a string


Q30.what do you mean by utility functions in java?how it is related to Static?
Ans.Utility Class as a set of methods that perform common, often reused functions, the functions tend to require no Object level state, that is they tend to be global functions. And that is why, in Java they tend to become implemented as static methods on a container class
Q29.Which Start method of thread class register a method to thread scheduler
Q28.Can we use main method with final?
Ans.final static void main(String args[]) yes, we do that it will work fine.

Q27.Is to possible to write and load your own version of core Java classes?
Ans.Error: Main method not found in class java.lang.String, please define the main method as:
   public static void main(String[] args)
1.javac has to compile the core classes.
2.There are checks done at runtime to prevent you loading duplicate classes.
3.You can't load any classes starting with java.. I believe, this was done to stop Microsoft doing naughty incompatible things.
4.You can't load two classes with the same name with the same class loader instance.

By default the class loader will check the parent loader before loading a class. This one is overridable (with the relevant security permissions)
   
Q26.if string is stored in string-pool, as it supports immutability then where are our custom immutable classes are stored in java.
Ans.The heap is the run-time data area from which memory for all class instances and arrays is allocated
1. a string contained in the pool still is stored in the heap memory, by definition, while the pool has a reference to it
2.Like strings contained in the pool are still stored in the heap memory, objects of your class are still stored in the heap memory when being referenced by whatever data structure used for the pool is referencing them. It’s not even necessary for the object to be immutable, to have such a pool, but the implied sharing of instances would cause semantic problems when mutations are possible. So creating a pool usually only makes sense for immutable objects.
3. lots of the wrapper classes have such sharing, the valueOf methods for Short, Integer and Long will return shared instances for values in the -128 … +127 range and implementations are allowed to share even more, whereas Byte and Boolean return shared instances for all possible values

Q25-2.How many threads being created?
Ans.	System.out.println("Active Thread " + Thread.activeCount() + " All StackTrace : " + Thread.getAllStackTraces());
 1.Signal Dispatcher
 2.main
 3.Finalizer
 4.Reference Handler
 5.Monitor Ctrl-Break

Q25.How to go through the collection without using any loop construct?
Ans.Recursion

Q1.What are those methods which are common to all the collection classes and interfaces?
Ans.All java object classes (which include all the collections) are derived from the base class called Object. This class has some methods which are available to all objects (because they are sub-classes)

Q1.What is JPA? Introduction to the Java Persistence API
Ans.As a specification, the Java Persistence API is concerned with persistence.
2. The JPA specification lets you define which objects should be persisted, and how those objects should be persisted in your Java applications.

By itself, JPA is not a tool or framework; rather, it defines a set of concepts that can be implemented by any tool or framework. While JPA's object-relational mapping (ORM) model was originally based on Hibernate



Why HashMap should not be used in multi threaded environment? 
Can it cause infinite loop as well?
When get method go to infinite loop in HashMap?
Ans.
Well, nothing is wrong — it depends on how you use it. For example, if you initialize the HashMap with just one thread and all threads are only reading from it, then it's perfectly fine.

One example of this is a Map that contains configuration properties. The real problem starts when at least one of those threads is updating the HashMap, i.e. adding, changing, or removing any key-value pair.

Since a put() operation can cause re-sizing, which can further lead to infinite loop, that's why either you should use a Hashtable or ConcurrentHashMap 

What is Rehashing?

 
Default capacity of HashMap is 16 and Load factor is 0.75, which means HashMap will double its capacity when 13th Key-Value pair enters in map (16 * 0.75 = 12).

Till 12th Key-value pair, Hashmap will keep putting items in map and as soon as you try to put 13th key-value pair, rehashing process starts. 

Load factor: Load factor is a measure "Till what load, hashmap can allow elements to put in it before its size is increased.


Rehasing reverses ordering of the nodes 
In Rehashing process, 
Hashmap creates a New Array(Buckets) of double size first.
Hashmap transfers key-value pairs from Old buckets to New buckets.  
Key-value pairs will be reversed in New buckets because Hashmap will add key-value pairs at the start in the New bucket and not at the end. 
Hashmap adds new key-value pairs at start to avoid traversing linked list every time and keep constant performance.


Question 14: Where does equals() and hashCode() method comes in the picture during the get() operation on HashMap?
Ans.When you provide a key object, first it’s hashcode method is called to calculate bucket location. Since a bucket may contain more than one entry as a linked list, each of those Map.Entry object is evaluated by using equals() method to see if they contain the actual key object or not.
