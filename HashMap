Q27.Is to possible to write and load your own version of core Java classes?
Ans.Error: Main method not found in class java.lang.String, please define the main method as:
   public static void main(String[] args)
1.javac has to compile the core classes.
2.There are checks done at runtime to prevent you loading duplicate classes.
3.You can't load any classes starting with java.. I believe, this was done to stop Microsoft doing naughty incompatible things.
4.You can't load two classes with the same name with the same class loader instance.

By default the class loader will check the parent loader before loading a class. This one is overridable (with the relevant security permissions)
   
Q26.if string is stored in string-pool, as it supports immutability then where are our custom immutable classes are stored in java.
Ans.The heap is the run-time data area from which memory for all class instances and arrays is allocated
1. a string contained in the pool still is stored in the heap memory, by definition, while the pool has a reference to it
2.Like strings contained in the pool are still stored in the heap memory, objects of your class are still stored in the heap memory when being referenced by whatever data structure used for the pool is referencing them. It’s not even necessary for the object to be immutable, to have such a pool, but the implied sharing of instances would cause semantic problems when mutations are possible. So creating a pool usually only makes sense for immutable objects.
3. lots of the wrapper classes have such sharing, the valueOf methods for Short, Integer and Long will return shared instances for values in the -128 … +127 range and implementations are allowed to share even more, whereas Byte and Boolean return shared instances for all possible values

Q25-2.How many threads being created?
Ans.	System.out.println("Active Thread " + Thread.activeCount() + " All StackTrace : " + Thread.getAllStackTraces());
 1.Signal Dispatcher
 2.main
 3.Finalizer
 4.Reference Handler
 5.Monitor Ctrl-Break

Q25.How to go through the collection without using any loop construct?
Ans.Recursion

Q1.What are those methods which are common to all the collection classes and interfaces?
Ans.All java object classes (which include all the collections) are derived from the base class called Object. This class has some methods which are available to all objects (because they are sub-classes)

Q1.What is JPA? Introduction to the Java Persistence API
Ans.As a specification, the Java Persistence API is concerned with persistence.
2. The JPA specification lets you define which objects should be persisted, and how those objects should be persisted in your Java applications.

By itself, JPA is not a tool or framework; rather, it defines a set of concepts that can be implemented by any tool or framework. While JPA's object-relational mapping (ORM) model was originally based on Hibernate



Why HashMap should not be used in multi threaded environment? 
Can it cause infinite loop as well?
When get method go to infinite loop in HashMap?
Ans.
Well, nothing is wrong — it depends on how you use it. For example, if you initialize the HashMap with just one thread and all threads are only reading from it, then it's perfectly fine.

One example of this is a Map that contains configuration properties. The real problem starts when at least one of those threads is updating the HashMap, i.e. adding, changing, or removing any key-value pair.

Since a put() operation can cause re-sizing, which can further lead to infinite loop, that's why either you should use a Hashtable or ConcurrentHashMap 

What is Rehashing?

 
Default capacity of HashMap is 16 and Load factor is 0.75, which means HashMap will double its capacity when 13th Key-Value pair enters in map (16 * 0.75 = 12).

Till 12th Key-value pair, Hashmap will keep putting items in map and as soon as you try to put 13th key-value pair, rehashing process starts. 

Load factor: Load factor is a measure "Till what load, hashmap can allow elements to put in it before its size is increased.


Rehasing reverses ordering of the nodes 
In Rehashing process, 
Hashmap creates a New Array(Buckets) of double size first.
Hashmap transfers key-value pairs from Old buckets to New buckets.  
Key-value pairs will be reversed in New buckets because Hashmap will add key-value pairs at the start in the New bucket and not at the end. 
Hashmap adds new key-value pairs at start to avoid traversing linked list every time and keep constant performance.


Question 14: Where does equals() and hashCode() method comes in the picture during the get() operation on HashMap?
Ans.When you provide a key object, first it’s hashcode method is called to calculate bucket location. Since a bucket may contain more than one entry as a linked list, each of those Map.Entry object is evaluated by using equals() method to see if they contain the actual key object or not.
