
Q35.When do you use an abstract class?
Q34.Can super class reference variable can hold an object of sub class?
Ans.
1.First approach (Referencing using Superclass reference): A reference variable of a superclass can be used to a refer any subclass object derived from that superclass. If the methods are present in SuperClass, but overridden by SubClass, it will be the overridden method that will be executed.
2.Second approach (Referencing using subclass reference) : A subclass reference can be used to refer its object.
Disadvantage : By using superclass reference, we will have access only to those parts(methods and variables) of the object defined by the superclass. For example, we can not access seatHeight variable or call setHeight(int newValue) method using Bicycle reference in above first example. This is because they are defined in subclass not in the superclass.

Advantage : By using subclass reference, we will have access to both parts(methods and variables) of the object defined by the superclass or subclass. For example, we can call setHeight(int newValue) method or speedUp(int increment) method using MountainBike reference in above first example


Q33.What is the Hashcode method used for in Java?
Ans.hashing algorithms stand behind some of the most popular collections we have available – such as the HashMap.When using a hash table, these collections calculate the hash value for a given key using the hashCode() method and use this value internally to store the data – so that access operations are much more efficient.Simply put, hashCode() returns an integer value, generated by a hashing algorithm.Objects that are equal (according to their equals()) must return the same hash code.

@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    System.out.println("Object hashCOde :" + this.name + hash);
    return hash;
}

each time an object is stored in the hash map and checked with the containsKey() method, hashCode() is invoked and the computed hash code.

	Employee emp1 = new Employee("anuj", 12, "Male");
		Employee emp2 = new Employee("amit", 12, "Male");
		Employee emp3 = new Employee("anuj", 12, "male");
		Map<Employee, Employee> map = new HashMap<>();
		map.put(emp1, emp2);
		map.put(emp2, emp3);

		if (map.containsKey(emp3)) {
			System.out.println("Employee found in Collections");
		}
Output:
Object hashCOde :anuj77327002
Object hashCOde :amit77325679
Object hashCOde :anuj106879674

Q32.What is the use of equals method in Java?
Ans.
1.This method’s functionality is to check if the object invoking this method is equal to another object passed as an argument. It should return true if the objects are equal, otherwise it should return false.
2.It is generally necessary to override the hashCode() method whenever the equals() method is overridden, so as to maintain the general contract for the hashCode() method, which states that equal objects must have equal hash codes.

@Override
	public boolean equals(Object obj) {

		if (obj == null) {
			return false;
		}
      if (this == obj)
			return true;
		if (!(obj instanceof Employee)) {
			return false;
		}
		Employee emp = (Employee) obj;

		return (this.name.equals(emp.name)) && (this.age == emp.age) && (this.gender.equals(emp.gender));

	}
   
  1.Whenever a.equals(b), then a.hashCode() must be same as b.hashCode().

Q31.Explain about toString method ?
Ans.
1.It returns a string representation of the object The result should be a concise but informative representation that is easy for a person to read. It's also widely used for logging, and for passing informative error messages to Exception constructors and assertions.
2.The toString() is a method that is defined in the java.lang.Object class and thus, every object has one, however, it prints out, for the most part, meaningless information. Since its default implementation doesn't provide much information.
3.By default the toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object.
4.getClass().getName() + '@' + Integer.toHexString(hashCode()).
5. We can override toString method in our Class like 

@Override
	public String toString() {
		return "Manufacturer: " + name + " \nGear: " + gear;
	}
   
   
6.How to toString() works?
Ans.toString() with Concatenation 
Whenever we concatenate any other primitive data type, or object of other classes with a String object, toString() function or valueOf() function is called automatically to change the other object or primitive type into string, for successful concatenation.

int gear = 6;
String str = "Car has " + gear + " gears.";

Q32.When to use toString() method?
Ans.In Java, toString method guarantees that an object can be represented textually.This is especially useful for logging, debugging, or any other circumstance where you need to be able to render any and every object you encounter as a string


Q30.what do you mean by utility functions in java?how it is related to Static?
Ans.Utility Class as a set of methods that perform common, often reused functions, the functions tend to require no Object level state, that is they tend to be global functions. And that is why, in Java they tend to become implemented as static methods on a container class
Q29.Which Start method of thread class register a method to thread scheduler
Q28.Can we use main method with final?
Ans.final static void main(String args[]) yes, we do that it will work fine.

Q27.Is to possible to write and load your own version of core Java classes?
Ans.Error: Main method not found in class java.lang.String, please define the main method as:
   public static void main(String[] args)
1.javac has to compile the core classes.
2.There are checks done at runtime to prevent you loading duplicate classes.
3.You can't load any classes starting with java.. I believe, this was done to stop Microsoft doing naughty incompatible things.
4.You can't load two classes with the same name with the same class loader instance.

By default the class loader will check the parent loader before loading a class. This one is overridable (with the relevant security permissions)
   
Q26.if string is stored in string-pool, as it supports immutability then where are our custom immutable classes are stored in java.
Ans.The heap is the run-time data area from which memory for all class instances and arrays is allocated
1. a string contained in the pool still is stored in the heap memory, by definition, while the pool has a reference to it
2.Like strings contained in the pool are still stored in the heap memory, objects of your class are still stored in the heap memory when being referenced by whatever data structure used for the pool is referencing them. It’s not even necessary for the object to be immutable, to have such a pool, but the implied sharing of instances would cause semantic problems when mutations are possible. So creating a pool usually only makes sense for immutable objects.
3. lots of the wrapper classes have such sharing, the valueOf methods for Short, Integer and Long will return shared instances for values in the -128 … +127 range and implementations are allowed to share even more, whereas Byte and Boolean return shared instances for all possible values

Q25-2.How many threads being created?
Ans.	System.out.println("Active Thread " + Thread.activeCount() + " All StackTrace : " + Thread.getAllStackTraces());
 1.Signal Dispatcher
 2.main
 3.Finalizer
 4.Reference Handler
 5.Monitor Ctrl-Break

Q25.How to go through the collection without using any loop construct?
Ans.Recursion

Q1.What are those methods which are common to all the collection classes and interfaces?
Ans.All java object classes (which include all the collections) are derived from the base class called Object. This class has some methods which are available to all objects (because they are sub-classes)

Q1.What is JPA? Introduction to the Java Persistence API
Ans.As a specification, the Java Persistence API is concerned with persistence.
2. The JPA specification lets you define which objects should be persisted, and how those objects should be persisted in your Java applications.

By itself, JPA is not a tool or framework; rather, it defines a set of concepts that can be implemented by any tool or framework. While JPA's object-relational mapping (ORM) model was originally based on Hibernate



Why HashMap should not be used in multi threaded environment? 
Can it cause infinite loop as well?
When get method go to infinite loop in HashMap?
Ans.
Well, nothing is wrong — it depends on how you use it. For example, if you initialize the HashMap with just one thread and all threads are only reading from it, then it's perfectly fine.

One example of this is a Map that contains configuration properties. The real problem starts when at least one of those threads is updating the HashMap, i.e. adding, changing, or removing any key-value pair.

Since a put() operation can cause re-sizing, which can further lead to infinite loop, that's why either you should use a Hashtable or ConcurrentHashMap 

What is Rehashing?

 
Default capacity of HashMap is 16 and Load factor is 0.75, which means HashMap will double its capacity when 13th Key-Value pair enters in map (16 * 0.75 = 12).

Till 12th Key-value pair, Hashmap will keep putting items in map and as soon as you try to put 13th key-value pair, rehashing process starts. 

Load factor: Load factor is a measure "Till what load, hashmap can allow elements to put in it before its size is increased.


Rehasing reverses ordering of the nodes 
In Rehashing process, 
Hashmap creates a New Array(Buckets) of double size first.
Hashmap transfers key-value pairs from Old buckets to New buckets.  
Key-value pairs will be reversed in New buckets because Hashmap will add key-value pairs at the start in the New bucket and not at the end. 
Hashmap adds new key-value pairs at start to avoid traversing linked list every time and keep constant performance.


Question 14: Where does equals() and hashCode() method comes in the picture during the get() operation on HashMap?
Ans.When you provide a key object, first it’s hashcode method is called to calculate bucket location. Since a bucket may contain more than one entry as a linked list, each of those Map.Entry object is evaluated by using equals() method to see if they contain the actual key object or not.
